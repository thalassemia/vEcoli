======
Stores
======

Stores are upgraded dictionaries that store the simulation state. The 
descriptions for each type of store below are prefaced by a series of 
relevant attributes that consist of:

:Path: Location of the store for use in process topologies
:Updater: Function used to apply updates to the store
:Divider: Function used to split the store during cell division
:Serializer: Instance of :py:class:`vivarium.core.registry.Serializer` 
    used to serialize store data before being emitted
:Schema: Helper function for store in ``ports_schema`` methods
:Helpers: Other useful helper functions

--------------
Bulk Molecules
--------------

:Path: ``('bulk',)``
:Updater: :py:func:`ecoli.library.schema.bulk_numpy_updater`
:Divider: :py:func:`ecoli.library.schema.divide_bulk`
:Serializer: :py:class:`ecoli.library.schema.get_bulk_counts`
:Schema: :py:func:`ecoli.library.schema.numpy_schema`
:Helpers: :py:func:`ecoli.library.schema.bulk_name_to_idx`,
    :py:func:`ecoli.library.schema.counts`

.. WARNING::
    ``vivarium-core`` **does not** copy store values so processes must
    be careful not to unintentionally modify mutable values. The bulk 
    molecules array is read-only for extra protection (see ``WRITEABLE`` 
    flag in :py:attr:`numpy.ndarray.flags`).

.. note::
    Bulk molecules are named as such because they represent species for 
    which all molecules are treated as interchangeable (e.g. water).

The bulk molecules store consists of a 
`structured Numpy array <https://numpy.org/doc/stable/user/basics.rec.html>`_ 
with the following named fields:

    1. ``id`` (:py:class:`str`): Names of bulk molecules as pulled from `EcoCyc <https://ecocyc.org/>`_
        Each end with a bracketed "location tag" (e.g. ``[c]``) containing
        one of the abbreviations defined in the 
        ``reconstruction/ecoli/flat/compartments.tsv`` file (see
        `Cell Component Ontology <http://brg.ai.sri.com/CCO/downloads/cco.html>`_)
    2. ``count`` (:py:attr:`numpy.int64`): Counts of bulk molecules
        Instead of the full structured array, the ``evolve_state`` method of partitioned
        processes receive a one-dimensional array of partitioned counts (see :ref:`partitioning`).
    3. ``{}_submass`` (:py:attr:`numpy.float64`): Field for each submass
        Eight submasses are rRNA, tRNA, mRNA, miscRNA, nonspecific_RNA, protein, metabolite, water, DNA

.. _initialization:
Initialization
==============
To create the initial value for this store, the model will go through 
the following three options in order:

    1. Load custom initial state
        Set ``initial_state`` option for 
        :py:mod:`ecoli.experiments.ecoli_master_sim`

    2. Load from saved state JSON
        Set ``initial_state_file`` option for 
        :py:mod:`ecoli.experiments.ecoli_master_sim`

    3. Generate from ``sim_data``
        :py:meth:`ecoli.library.sim_data.LoadSimData.generate_initial_state` 
        uses the ``sim_data`` object generated by the ParCa to calculate 
        initial state


.. _partitioning:
Partitioning
============

Indexing
========
Processes typically use the :py:func:`ecoli.library.schema.bulk_name_to_idx` helper function 
to get the indices for a set of molecules (e.g. all NTPs). These indices are typically cached 
as instance attributes (e.g. ``self.ntp_idx``) in the ``next_update`` method of a process.

Though counts can be directly retrieved from the Numpy structured array (e.g. 
``states['bulk']['count'][self.ntp_idx]``), the value of the bulk store seen by
partitioned processes is a simple unstructured Numpy array. To standardize count 
access across processes, the helper function 
:py:func:`ecoli.library.schema.counts` can handle both of these scenarios and 
also guarantees that the returned counts can be safely edited without 
unintentionally mutating the source array.


----------------
Unique Molecules
----------------

:Path: ``('unique',)``
:Updater: :py:meth:`ecoli.library.schema.UniqueNumpyUpdater.updater`
:Dividers: See :py:data:`ecoli.library.schema.UNIQUE_DIVIDERS`
:Serializer: :py:class:`ecoli.library.schema.get_unique_fields`
:Schema: :py:func:`ecoli.library.schema.numpy_schema`
:Helpers: :py:func:`ecoli.library.schema.attrs`

.. WARNING::
    ``vivarium-core`` **does not** copy store values so processes must
    be careful not to unintentionally modify mutable values. Each unique 
    molecule array is read-only for extra protection (see ``WRITEABLE`` 
    flag in :py:attr:`numpy.ndarray.flags`).

.. note::
    Unique molecules are named as such because they represent species for 
    which individual molecules are not treated as interchangeable (e.g. 
    different RNA molecules may have different sequences).

The unique molecules store contains a substore for each unique molecule (e.g. 
RNA, active RNAP, etc.). Each unique molecule substore contains a 
`structured Numpy array <https://numpy.org/doc/stable/user/basics.rec.html>`_ 
with a variety of named fields, each representing an attribute of interest 
for that class of unique molecules (e.g. ``coordinates`` for a ``gene`` unique 
molecule). All unique molecules will have the following named fields:

    1. ``unique_index`` (:py:class:`int`): Unique identifier for each unique molecule
        When processes add new unique molecules, the helper function 
        :py:func:`ecoli.library.schema.create_unqiue_indices` is used to generate 
        unique indices for each molecule to be added.
    2. ``_entryState`` (:py:attr:`numpy.int8`): 1 for active row, 0 for inactive row
        When unique molecules are deleted (e.g. RNA degradation), all of their data, 
        including the ``_entryState`` field, is set to 0. When unique molecues are 
        added (e.g. RNA transcription), the updater places the data for these new 
        molecules into the rows that are identified as inactive by the helper function 
        :py:func:`ecoli.library.schema.get_free_indices`, which also grows the array 
        if necessary. 
    3. ``massDiff_{}`` (:py:attr:`numpy.float64`): Field for each dynamic submass
        The eight submasses are rRNA, tRNA, mRNA, miscRNA, nonspecific_RNA, protein, 
        metabolite, water, and DNA. An example of a dynamic submass is the constantly
        changing protein mass of the polypeptide associated with an actively 
        translating ribosome.

Initialization
==============
See :ref:`initialization`.

Accessing
=========
Processes use the :py:func:`ecoli.library.schema.attrs` helper function to access 
any number of attributes for all active (``_entryState`` is 1) unique molecules 
of a given type (e.g. RNA, active RNAP, etc.).  

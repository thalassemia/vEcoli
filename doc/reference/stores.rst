======
Stores
======

Stores are upgraded dictionaries that store the simulation state. The 
descriptions for each type of store below are prefaced by a series of 
relevant attributes that consist of:

:Path: Location of the store for use in process topologies
:Updater: Function used to apply updates to the store
:Divider: Function used to split the store during cell division
:Serializer: Instance of :py:class:`vivarium.core.registry.Serializer` 
    used to serialize store data before being emitted
:Schema: Helper function for store in ``ports_schema`` methods
:Helpers: Other useful helper functions

--------------
Bulk Molecules
--------------

:Path: ``('bulk',)``
:Updater: :py:func:`ecoli.library.schema.bulk_numpy_updater`
:Divider: :py:func:`ecoli.library.schema.divide_bulk`
:Serializer: :py:class:`ecoli.library.schema.get_bulk_counts`
:Schema: :py:func:`ecoli.library.schema.numpy_schema`
:Helpers: :py:func:`ecoli.library.schema.bulk_name_to_idx`,
    :py:func:`ecoli.library.schema.counts`

.. WARNING::
    ``vivarium-core`` **does not** copy store values so processes must
    be careful not to unintentionally modify mutable values. The bulk 
    molecules array is read-only for extra protection (see ``WRITEABLE`` 
    flag in :py:attr:`numpy.ndarray.flags`).

.. note::
    Bulk molecules are named as such because they represent species for 
    which all molecules are treated as interchangeable (e.g. water).

The bulk molecules store consists of a 
`structured Numpy array <https://numpy.org/doc/stable/user/basics.rec.html>`_ 
with the following named fields:

    1. ``id`` (:py:class:`str`): Names of bulk molecules as pulled from `EcoCyc <https://ecocyc.org/>`_
        Each end with a bracketed "location tag" (e.g. ``[c]``) containing
        one of the abbreviations defined in the 
        ``reconstruction/ecoli/flat/compartments.tsv`` file (see
        `Cell Component Ontology <http://brg.ai.sri.com/CCO/downloads/cco.html>`_)
    2. ``count`` (:py:attr:`numpy.int64`): Counts of bulk molecules
        Instead of the full structured array, the ``evolve_state`` method of partitioned
        processes receive a one-dimensional array of partitioned counts (see :ref:`partitioning`).
    3. ``{}_submass`` (:py:attr:`numpy.float64`): Field for each submass
        Eight submasses are rRNA, tRNA, mRNA, miscRNA, nonspecific_RNA, protein, metabolite, water, DNA

.. _initialization:
Initialization
==============
To create the initial value for this store, the model will go through 
the following three options in order:

    1. Load custom initial state
        Set ``initial_state`` option for 
        :py:mod:`ecoli.experiments.ecoli_master_sim`

    2. Load from saved state JSON
        Set ``initial_state_file`` option for 
        :py:mod:`ecoli.experiments.ecoli_master_sim`

    3. Generate from ``sim_data``
        :py:meth:`ecoli.library.sim_data.LoadSimData.generate_initial_state` 
        uses the ``sim_data`` object generated by the ParCa to calculate 
        initial state


.. _partitioning:
Partitioning
============
To support the use of independent sub-models for different biological processes 
(e.g. FBA for metabolism, Gillespie for complexation, etc.), the model allows 
processes to run mostly independently. At a high level, over the course of a 
single simulation step, each process will see the simulation state as it was 
before any other process has run. Each process will then calculate an update 
to apply to the simulation state and all updates will be simultaneously 
applied once all processes have run. 

This setup has a potential problem: two processes may both decide to deplete 
the count of the same molecule, resulting in a final count that is negative. 
To prevent this from happening, the model forces processes to communicate 
their bulk molecule requests to a special allocator process 
(:py:class:`ecoli.processes.allocator.Allocator`). The allocator process 
will divide the bulk molecules so that each process sees a functional count 
that is proportional to their request.

For example, if process A requests 100 of molecule X and process B requests 
400 of molecule X but the cell only has 400 molecules of X, the allocator 
will divde the molecules as follows:

- Process A: :math:`\frac{100}{100 + 400} * 400 = 80` molecules of X 
- Process B: :math:`\frac{400}{100 + 400} * 400 = 320` molecules of X

.. note::
    Processes in the model are more dependent on one another than in this 
    simplified example.

For example, since molecule binding and complexation 
events occur on timescales much shorter than the default 1 second 
simulation timestep, we run :py:class:`~ecoli.processes.tf_unbinding.TfUnbinding`, 
update the simulation state, then run 
:py:class:`~ecoli.processes.equilibrium.Equilibrium` and 
:py:class:`~ecoli.processes.two_component_system.TwoComponentSystem`, 
update the simulation state, and finally run 
:py:class:`~ecoli.processes.tf_binding.TfBinding`, 
and update the simulation state. This allows transcription factors that are 
currently bound to promoters a chance to form complexes or participate in 
other reactions, better reflecting the transient binding dynamics of real cells.

To allow processes to run in this manner with a pre-specified order within 
each timestep, we can make use of a special subclass of typical Vivarium 
:py:class:`~vivarium.core.process.Process` instances called 
:py:class:`~vivarium.core.process.Step`. 

Indexing
========
Processes typically use the :py:func:`ecoli.library.schema.bulk_name_to_idx` helper function 
to get the indices for a set of molecules (e.g. all NTPs). These indices are typically cached 
as instance attributes (e.g. ``self.ntp_idx``) in the ``next_update`` method of a process.

Though counts can be directly retrieved from the Numpy structured array (e.g. 
``states['bulk']['count'][self.ntp_idx]``), the value of the bulk store seen by
partitioned processes is a simple unstructured Numpy array. To standardize count 
access across processes, the helper function 
:py:func:`ecoli.library.schema.counts` can handle both of these scenarios and 
also guarantees that the returned counts can be safely edited without 
unintentionally mutating the source array.


----------------
Unique Molecules
----------------

:Path: ``('unique',)``
:Updater: :py:meth:`ecoli.library.schema.UniqueNumpyUpdater.updater`
:Dividers: See :py:data:`ecoli.library.schema.UNIQUE_DIVIDERS`
:Serializer: :py:class:`ecoli.library.schema.get_unique_fields`
:Schema: :py:func:`ecoli.library.schema.numpy_schema`
:Helpers: :py:func:`ecoli.library.schema.attrs`

.. WARNING::
    ``vivarium-core`` **does not** copy store values so processes must
    be careful not to unintentionally modify mutable values. Each unique 
    molecule array is read-only for extra protection (see ``WRITEABLE`` 
    flag in :py:attr:`numpy.ndarray.flags`).

.. note::
    Unique molecules are named as such because they represent species for 
    which individual molecules are not treated as interchangeable (e.g. 
    different RNA molecules may have different sequences).

The unique molecules store contains a substore for each unique molecule (e.g. 
RNA, active RNAP, etc.). Each unique molecule substore contains a 
`structured Numpy array <https://numpy.org/doc/stable/user/basics.rec.html>`_ 
with a variety of named fields, each representing an attribute of interest 
for that class of unique molecules (e.g. ``coordinates`` for a ``gene`` unique 
molecule). All unique molecules will have the following named fields:

    1. ``unique_index`` (:py:class:`int`): Unique identifier for each unique molecule
        When processes add new unique molecules, the helper function 
        :py:func:`ecoli.library.schema.create_unqiue_indices` is used to generate 
        unique indices for each molecule to be added.
    2. ``_entryState`` (:py:attr:`numpy.int8`): 1 for active row, 0 for inactive row
        When unique molecules are deleted (e.g. RNA degradation), all of their data, 
        including the ``_entryState`` field, is set to 0. When unique molecues are 
        added (e.g. RNA transcription), the updater places the data for these new 
        molecules into the rows that are identified as inactive by the helper function 
        :py:func:`ecoli.library.schema.get_free_indices`, which also grows the array 
        if necessary. 
    3. ``massDiff_{}`` (:py:attr:`numpy.float64`): Field for each dynamic submass
        The eight submasses are rRNA, tRNA, mRNA, miscRNA, nonspecific_RNA, protein, 
        metabolite, water, and DNA. An example of a dynamic submass is the constantly
        changing protein mass of the polypeptide associated with an actively 
        translating ribosome.

Initialization
==============
See :ref:`initialization`.

Accessing
=========
Processes use the :py:func:`ecoli.library.schema.attrs` helper function to access 
any number of attributes for all active (``_entryState`` is 1) unique molecules 
of a given type (e.g. RNA, active RNAP, etc.).  
